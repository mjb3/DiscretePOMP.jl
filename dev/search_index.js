var documenterSearchIndex = {"docs":
[{"location":"arq/#ARQ-MCMC","page":"ARQ MCMC","title":"ARQ MCMC","text":"","category":"section"},{"location":"arq/#Introduction","page":"ARQ MCMC","title":"Introduction","text":"","category":"section"},{"location":"arq/","page":"ARQ MCMC","title":"ARQ MCMC","text":"TBA","category":"page"},{"location":"models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"This section provides instructions for generating model instances in DiscretePOMP.jl.","category":"page"},{"location":"models/#Predefined-models","page":"Models","title":"Predefined models","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"The package includes a set of predefined models, which can be instantiated easily:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"import DiscretePOMP               # simulation / inference for epidemiological models\nimport Distributions        # priors\n\nmodel = generate_model(\"SIS\", [100,1])","category":"page"},{"location":"models/#Customising-predefined-models","page":"Models","title":"Customising predefined models","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"DPOMPModels are mutable structs, which means that their properties can be altered after they have been instantiated. For example, we could specify a prior:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"model.prior = Distributions.Product(Distributions.Uniform.(zeros(2), [0.01, 0.5]))","category":"page"},{"location":"models/#Custom-models-from-scratch","page":"Models","title":"Custom models from scratch","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"Models can also be specified manually. For example, the model we just created could also be instantiated like so:","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"# rate function\nfunction sis_rf!(output, parameters::Array{Float64, 1}, population::Array{Int64, 1})\n    output[1] = parameters[1] * population[1] * population[2]\n    output[2] = parameters[2] * population[2]\nend\n# define obs function\nfunction obs_fn(y::Observation, population::Array{Int64, 1}, theta::Array{Float64,1})\n    y.val .= population\nend\n# prior\nprior = Distributions.Product(Distributions.Uniform.(zeros(2), [0.01, 0.05]))\n# obs model\nfunction si_gaussian(y::Observation, population::Array{Int64, 1}, theta::Array{Float64,1})\n    obs_err = 2\n    tmp1 = log(1 / (sqrt(2 * pi) * obs_err))\n    tmp2 = 2 * obs_err * obs_err\n    obs_diff = y.val[2] - population[2]\n    return tmp1 - ((obs_diff * obs_diff) / tmp2)\nend\ntm = [-1 1; 1 -1] # transition matrix\n# define model\nmodel = DPOMPModel(\"SIS\", sis_rf!, [100, 1], tm, obs_fn, si_gaussian, prior, 0)","category":"page"},{"location":"models/#Model-directory","page":"Models","title":"Model directory","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"Here we provide a brief overview of predefined models available in the package.","category":"page"},{"location":"models/#Epidemiological-models","page":"Models","title":"Epidemiological models","text":"","category":"section"},{"location":"models/#SIR-model","page":"Models","title":"SIR model","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"The canonical Kermack-McKendrick susceptible-infectious-recovered model is perhaps the best known example of state-space models used within the field of epidemiology.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"<img src=\"https://raw.githubusercontent.com/mjb3/DiscretePOMP.jl/master/docs/img/sir.png\" alt=\"SIR model\" style=\"height: 80px;\"/>","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"using DiscretePOMP\ngenerate_model(\"SIR\", [100, 1, 0])","category":"page"},{"location":"models/#SI-model","page":"Models","title":"SI model","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"The susceptible-infectious model is the simplest conceptual example of this class of model; two states and only one type of event.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"<img src=\"https://raw.githubusercontent.com/mjb3/DiscretePOMP.jl/master/docs/img/si.png\" alt=\"SI model\" style=\"height: 80px;\"/>","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"generate_model(\"SI\", [100, 1]);","category":"page"},{"location":"models/#SIS-model","page":"Models","title":"SIS model","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"Another common derivative of the SIR model.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"<img src=\"https://raw.githubusercontent.com/mjb3/DiscretePOMP.jl/master/docs/img/sis.png\" alt=\"SIS model\" style=\"height: 90px;\"/>","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"generate_model(\"SIS\", [100, 1]);","category":"page"},{"location":"models/#SEI-model","page":"Models","title":"SEI model","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"The SEI model includes an 'exposed' state, i.e. for modelling communicable diseases with latent non-infectious periods.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"<img src=\"https://raw.githubusercontent.com/mjb3/DiscretePOMP.jl/master/docs/img/sei.png\" alt=\"SEI model\" style=\"height: 80px;\"/>","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"generate_model(\"SEI\", [100, 0, 1]);","category":"page"},{"location":"models/#SEIR-model","page":"Models","title":"SEIR model","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"Somewhat obviously, the SEIR model concept combines the SEI with the SIR.","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"<img src=\"https://raw.githubusercontent.com/mjb3/DiscretePOMP.jl/master/docs/img/seir.png\" alt=\"SEIR model\" style=\"height: 80px;\"/>","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"generate_model(\"SEIR\", [100, 0, 1, 0]);","category":"page"},{"location":"models/#Others","page":"Models","title":"Others","text":"","category":"section"},{"location":"models/#The-Lotka-Volterra-predator-prey-model","page":"Models","title":"The Lotka-Volterra predator-prey model","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"<img src=\"https://raw.githubusercontent.com/mjb3/DiscretePOMP.jl/master/docs/img/lotka.png\" alt=\"Lotka model\" style=\"height: 80px;\"/>","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"generate_model(\"LOTKA\", [70, 70]);","category":"page"},{"location":"models/#Ross-MacDonald-two-species-Malaria-model","page":"Models","title":"Ross-MacDonald two-species Malaria model","text":"","category":"section"},{"location":"models/","page":"Models","title":"Models","text":"<img src=\"https://raw.githubusercontent.com/mjb3/DiscretePOMP.jl/master/docs/img/rossmac.png\" alt=\"Malaria model\" style=\"height: 240px;\"/>","category":"page"},{"location":"models/","page":"Models","title":"Models","text":"generate_model(\"ROSSMAC\", [100, 0, 400, 50]);","category":"page"},{"location":"examples/#Simple-example","page":"Simple example","title":"Simple example","text":"","category":"section"},{"location":"examples/#Introduction","page":"Simple example","title":"Introduction","text":"","category":"section"},{"location":"examples/","page":"Simple example","title":"Simple example","text":"Here we introduce the main features of the package using a simple example based on the one in the paper published by Pooley et al that described the model-based-proposal (MBP) method, (which is also one of the main inference methods implemented by DiscretePOMP.jl.)","category":"page"},{"location":"examples/","page":"Simple example","title":"Simple example","text":"Some familiarity with both Discrete state-space models and Bayesian inference is assumed, but as a brief refresher:","category":"page"},{"location":"examples/#DPOMP-(or-'compartmental'-models)","page":"Simple example","title":"DPOMP (or 'compartmental' models)","text":"","category":"section"},{"location":"examples/","page":"Simple example","title":"Simple example","text":"Perhaps the most familiar (to most people) example of these are the epidemiological variants, and in particular SIR and closely related SIS model, as illustrated below.","category":"page"},{"location":"examples/","page":"Simple example","title":"Simple example","text":"<img src=\"https://raw.githubusercontent.com/mjb3/DiscretePOMP.jl/master/docs/img/sis.png\" alt=\"SIS model\" style=\"height: 120px;\"/>","category":"page"},{"location":"examples/","page":"Simple example","title":"Simple example","text":"Individuals are assumed to take one of n discrete states –in this case Susceptible or Infectious.","category":"page"},{"location":"examples/","page":"Simple example","title":"Simple example","text":"Individuals are also assumed to 'migrate' between states randomly at rates defined as a function of the overall system state. For example, here the rate of the new infections (S -> I) is defined by product of the number of infectious and the number of susceptible individuals, scaled by an unknown contact rate parameter Beta. [ADD GREEK]","category":"page"},{"location":"examples/#Bayesian-inference","page":"Simple example","title":"Bayesian inference","text":"","category":"section"},{"location":"examples/","page":"Simple example","title":"Simple example","text":"pi(thetay) = fracpi(theta) pi(ytheta)pi(y) propto pi(theta) pi(ytheta)\nendequation","category":"page"},{"location":"examples/","page":"Simple example","title":"Simple example","text":"pi(ytheta) = f(theta)","category":"page"},{"location":"examples/#Defining-models","page":"Simple example","title":"Defining models","text":"","category":"section"},{"location":"examples/#Predefined-models","page":"Simple example","title":"Predefined models","text":"","category":"section"},{"location":"examples/","page":"Simple example","title":"Simple example","text":"The package includes a set of predefined models, which can be instantiated easily:","category":"page"},{"location":"examples/","page":"Simple example","title":"Simple example","text":"import DiscretePOMP               # simulation / inference for epidemiological models\nimport Random               # other assorted packages used incidentally\nimport DataFrames\nimport Distributions\n\nmodel = generate_model(\"SIS\", [100,1])","category":"page"},{"location":"examples/#Customising-models","page":"Simple example","title":"Customising models","text":"","category":"section"},{"location":"examples/","page":"Simple example","title":"Simple example","text":"Models can also be specified manually. This is described further in the Models section.","category":"page"},{"location":"examples/#Simulation","page":"Simple example","title":"Simulation","text":"","category":"section"},{"location":"examples/","page":"Simple example","title":"Simple example","text":"The main purpose of the package is to provide an automated framework for parameter inference, described in the next section. However much can also be learned from the use of simulated data; data obtained by generating [i.e. sampling] realisations of the model, generally referred to herein as 'trajectories'. For example, it can be an aid to intuition with respect to the internal dynamics mathematically described by the model, or as a method for predicting system behaviour under certain conditions.","category":"page"},{"location":"examples/","page":"Simple example","title":"Simple example","text":"The package implements the Gillespie direct method algorithm for simulation. It can be invoked thusly:","category":"page"},{"location":"examples/","page":"Simple example","title":"Simple example","text":"Random.seed!(1)\ntheta = [0.003, 0.1]\nx = gillespie_sim(model, theta)\t  # run simulation\np = plot_trajectory(x)            # plot (optional)","category":"page"},{"location":"examples/","page":"Simple example","title":"Simple example","text":"<img src=\"https://raw.githubusercontent.com/mjb3/DiscretePOMP.jl/master/docs/img/sis_sim.png\" alt=\"SIS simulation\" style=\"height: 260px;\"/>","category":"page"},{"location":"examples/#Inference","page":"Simple example","title":"Inference","text":"","category":"section"},{"location":"examples/","page":"Simple example","title":"Simple example","text":"Here we demonstrate the package's functionality for [single-model] Bayesian inference using two of the algorithms implemented by the package; data-augmented Markov chain Monte Carlo (MCMC), and iterative-batch-importance sampling (IBIS).","category":"page"},{"location":"examples/","page":"Simple example","title":"Simple example","text":"First though, it is necessary to define an appropriate prior distribution, using the Distributions package:","category":"page"},{"location":"examples/","page":"Simple example","title":"Simple example","text":"model.prior = Distributions.Product(Distributions.Uniform.(zeros(2), [0.1, 0.5]))","category":"page"},{"location":"examples/#MCMC","page":"Simple example","title":"MCMC","text":"","category":"section"},{"location":"examples/","page":"Simple example","title":"Simple example","text":"The first inference algorithm is MCMC; is a form of rejection sampling. The default number of Markov chains run for an analysis is three, and the Gelman-Rubin convergence diagnostic is carried out by default:","category":"page"},{"location":"examples/","page":"Simple example","title":"Simple example","text":"results = run_mcmc_analysis(model, y)\ntabulate_results(results)\n# trace plot of contact parameter (optional)\nprintln(plot_parameter_trace(results, 1))","category":"page"},{"location":"examples/","page":"Simple example","title":"Simple example","text":"<img src=\"https://raw.githubusercontent.com/mjb3/DiscretePOMP.jl/master/docs/img/trace.png\" alt=\"SIS simulation\" style=\"height: 80px;\"/>","category":"page"},{"location":"examples/#IBIS","page":"Simple example","title":"IBIS","text":"","category":"section"},{"location":"examples/","page":"Simple example","title":"Simple example","text":"The second class of algorithm we demonstrate here, is iterative-batch-importance sampling.","category":"page"},{"location":"examples/","page":"Simple example","title":"Simple example","text":"results = run_ibis_analysis(model, y)\ntabulate_results(results)","category":"page"},{"location":"examples/","page":"Simple example","title":"Simple example","text":"The default configuration is particle [filter]-IBIS (i.e. the SMC^2 algorithm) but MBP can be used instead.","category":"page"},{"location":"examples/#Model-comparison","page":"Simple example","title":"Model comparison","text":"","category":"section"},{"location":"examples/","page":"Simple example","title":"Simple example","text":"Finally, we describe how to compare models using the Bayes factor. First, we define an SEIS model to compare the SIS model/data with:","category":"page"},{"location":"examples/","page":"Simple example","title":"Simple example","text":"<img src=\"https://raw.githubusercontent.com/mjb3/DiscretePOMP.jl/master/docs/img/seis.png\" alt=\"SEIS model\" style=\"height: 80px;\"/>","category":"page"},{"location":"examples/","page":"Simple example","title":"Simple example","text":"# define model to compare against\nseis_model = generate_model(\"SEIS\", [100,0,1])\nseis_model.prior = Distributions.Product(Distributions.Uniform.(zeros(3), [0.1,0.5,0.5]))\nseis_model.obs_model = partial_gaussian_obs_model(2.0, seq = 3, y_seq = 2)","category":"page"},{"location":"examples/","page":"Simple example","title":"Simple example","text":"seq here denotes the compartment that is observed (i.e. infectious individuals) in the SEIS model state space. Since the observations data y is formatted based on the SIS model, we also specify that column as y_seq.","category":"page"},{"location":"examples/","page":"Simple example","title":"Simple example","text":"Finally, we run the comparison, tabulate and plot the results:","category":"page"},{"location":"examples/","page":"Simple example","title":"Simple example","text":"# run comparison\nmodels = [model, seis_model]\nmcomp = run_model_comparison_analysis(models, y)\ntabulate_results(mcomp; null_index = 1)\nprintln(plot_model_comparison(mcomp))","category":"page"},{"location":"manual/#Package-manual","page":"Package manual","title":"Package manual","text":"","category":"section"},{"location":"manual/","page":"Package manual","title":"Package manual","text":"Pages = [\"manual.md\"]\nDepth = 3","category":"page"},{"location":"manual/#Types","page":"Package manual","title":"Types","text":"","category":"section"},{"location":"manual/#Model-types","page":"Package manual","title":"Model types","text":"","category":"section"},{"location":"manual/","page":"Package manual","title":"Package manual","text":"DPOMPModel\nParticle\nEvent\nObservation\nARQModel","category":"page"},{"location":"manual/#DiscretePOMP.DPOMPModel","page":"Package manual","title":"DiscretePOMP.DPOMPModel","text":"DPOMPModel\n\nA mutable struct which represents a DSSCT model (see Models for further details).\n\nFields\n\nmodel_name          – string, e,g, \"SIR\".\nrate_function       – event rate function.\ninitial_condition   – initial condition.\nm_transition        – transition matrix.\n`obs_function         – observation function, use this to add 'noise' to simulated observations.\nobs_model           – observation model likelihood function.\nprior               – prior [multivariate] Distributions.Distribution.\nt0_index            – index of the parameter that represents the initial time. 0 if fixed at 0.0.\n\n\n\n\n\n","category":"type"},{"location":"manual/#DiscretePOMP.Particle","page":"Package manual","title":"DiscretePOMP.Particle","text":"Particle\n\nE.g. the main results of a simulation including the initial and final conditions, but not the full state trajectory.\n\nFields\n\ntheta               – e.g. simulation parameters.\ninitial_condition   – initial system state.\nfinal_condition     – final system state.\ntrajectory          – the event history.\nlog_like            – trajectory log likelihood, mainly for internal use.\n\n\n\n\n\n","category":"type"},{"location":"manual/#DiscretePOMP.Event","page":"Package manual","title":"DiscretePOMP.Event","text":"Event\n\nRequires no explanation.\n\nFields\n\ntime        – the time of the event.\nevent_type  – indexes the rate function and transition matrix.\n\n\n\n\n\n","category":"type"},{"location":"manual/#DiscretePOMP.Observation","page":"Package manual","title":"DiscretePOMP.Observation","text":"Observation\n\nA single observation. Note that by default val has the same size as the model state space. However that is not necessary - it need only be compatible with the observation model.\n\nFields\n\ntime        – similar to Event.time, the time of the observation.\nobs_id      – <1 if not a resampling step.\nprop        – optional information for the observation model.\nval         – the observation value.\n\n\n\n\n\n","category":"type"},{"location":"manual/#DiscretePOMP.ARQMCMC.ARQModel","page":"Package manual","title":"DiscretePOMP.ARQMCMC.ARQModel","text":"ARQModel\n\nContains the PDF (or estimate, or approximation of the target density - a function) and parameter density, which together specify the model.\n\nFields\n\npdf         – prior density function.\nsample_interval     – An array specifying the (fixed or fuzzy) interval between samples.\n\n\n\n\n\n","category":"type"},{"location":"manual/#Results","page":"Package manual","title":"Results","text":"","category":"section"},{"location":"manual/","page":"Package manual","title":"Package manual","text":"SimResults\nImportanceSample\nRejectionSample\nMCMCSample\nARQMCMCSample","category":"page"},{"location":"manual/#DiscretePOMP.SimResults","page":"Package manual","title":"DiscretePOMP.SimResults","text":"SimResults\n\nThe results of a simulation, including the full state trajectory.\n\nFields\n\nmodel_name      – string, e,g, \"SIR\".\nparticle        – the 'trajectory' variable, of type Particle.\npopulation      – records the final system state.\nobservations    – simulated observations data (an Array of Observation types.)\n\n\n\n\n\n","category":"type"},{"location":"manual/#DiscretePOMP.ImportanceSample","page":"Package manual","title":"DiscretePOMP.ImportanceSample","text":"ImportanceSample\n\nThe results of an importance sampling analysis, such as iterative batch importance sampling algorithms.\n\nFields\n\nmu              – weighted sample mean.\ncv              – weighted covariance.\ntheta           – two dimensional array of samples, e.g. parameter; iteration.\nweight          – sample weights.\nrun_time        – application run time.\nbme             – Estimate (or approximation) of the Bayesian model evidence.\n\n\n\n\n\n","category":"type"},{"location":"manual/#DiscretePOMP.RejectionSample","page":"Package manual","title":"DiscretePOMP.RejectionSample","text":"RejectionSample\n\nEssentially, the main results of an MCMC analysis, consisting of samples, mean, and covariance matrix.\n\nFields\n\nsamples         – three dimensional array of samples, e.g. parameter; iteration; Markov chain.\nmu              – sample mean.\ncv              – sample covariance matrix.\n\n\n\n\n\n","category":"type"},{"location":"manual/#DiscretePOMP.MCMCSample","page":"Package manual","title":"DiscretePOMP.MCMCSample","text":"MCMCSample\n\nThe results of an MCMC analysis, mainly consisting of a RejectionSample.\n\nFields\n\nsamples         – samples of type RejectionSample.\nadapt_period    – adaptation (i.e. 'burn in') period.\nsre             – scale reduction factor estimate, i.e. Gelman diagnostic.\nrun_time        – application run time.\n\n\n\n\n\n","category":"type"},{"location":"manual/#DiscretePOMP.ARQMCMC.ARQMCMCSample","page":"Package manual","title":"DiscretePOMP.ARQMCMC.ARQMCMCSample","text":"ARQMCMCSample\n\nThe results of an ARQ MCMC analysis including the ImportanceSample and resampled RejectionSample.\n\nThe sre scale factor reduction estimates relate the rejection (re)samples to the underlying importance sample.\n\nFields\n\nimp_sample          – main results, i.e. ImportanceSample.\nsamples             – resamples, of type RejectionSample.\nadapt_period        – adaptation (i.e. 'burn in') period.\nsample_dispersal    – number of distinct [possible] sample values along each dimension in the unit cube.\nsample_limit        – maximum number of samples per theta tupple.\ngrid_range          – bounds of the parameter space.\nsre                 – scale reduction factor estimate, i.e. Gelman diagnostic. NB. only valid for resamples.\nrun_time            – application run time.\nsample_cache        – a link to the underlying likelihood cache - can be reused.\n\n\n\n\n\n","category":"type"},{"location":"manual/#Functions","page":"Package manual","title":"Functions","text":"","category":"section"},{"location":"manual/#Models","page":"Package manual","title":"Models","text":"","category":"section"},{"location":"manual/","page":"Package manual","title":"Package manual","text":"generate_model\ngenerate_custom_model\npartial_gaussian_obs_model","category":"page"},{"location":"manual/#DiscretePOMP.generate_model","page":"Package manual","title":"DiscretePOMP.generate_model","text":"generate_model(model_name, initial_condition; freq_dep = false, obs_error = 2.0)\n\nGenerates an DPOMPModel instance. Observation models are generated using the partial_gaussian_obs_model function, with `σ = obs_error (see that functions entry for further details.)\n\nParameters\n\nmodel_name          – the model, e.g. \"SI\"; \"SIR\"; \"SEIR\"; etc\ninitial_condition   – initial condition.\n\nOptional parameters\n\nfreq_dep            – epidemiological models only, set to true for frequency-dependent contact rates.\nobs_error           – average observation error (default = 2.)\n\nmodel_name options\n\n\"SI\"\n\"SIR\"\n\"SIS\"\n\"SEI\"\n\"SEIR\"\n\"SEIS\"\n\"SEIRS\"\n\"PREDPREY\"\n\"ROSSMAC\"\n\nExamples\n\ngenerate_model(\"SIS\", [100,1])\n\n\n\n\n\n","category":"function"},{"location":"manual/#DiscretePOMP.generate_custom_model","page":"Package manual","title":"DiscretePOMP.generate_custom_model","text":"generate_custom_model(model_name, rate_function, initial_condition, m_transition; ... )\n\nGenerates an DPOMPModel instance. Observation models are generated using the partial_gaussian_obs_model function, with `σ = obs_error (see that functions entry for further details.)\n\nParameters\n\nmodel_name          – the model, e.g. \"SIR\", \"SEIR-custom\", etc.\nrate_function       – event rate function.\ninitial_condition   – initial condition\nm_transition        – transition matrix.\n\nOptional parameters\n\n`observation_function – observation function, use this to add 'noise' to simulated observations.\nobs_error           – average observation error (default = 2.)\nobs_model           – use this option to manuallu specify the observation model likelihood function.\nprior_density       – prior density function.\nt0_index            – index of the parameter that represents the initial time. 0 if fixed at 0.0.\n\nExamples\n\ngenerate_custom_model(\"SIS\", [100,1])\n\n\n\n\n\n","category":"function"},{"location":"manual/#DiscretePOMP.partial_gaussian_obs_model","page":"Package manual","title":"DiscretePOMP.partial_gaussian_obs_model","text":"partial_gaussian_obs_model(σ = 2.0; seq = 2, y_seq = seq)\n\nGenerate a simple Gaussian observation model. So-called because the accuracy of observations is 'known' and [assumed to be] normally distributed according to~N(0, σ), where observation error σ can be specified by the user.\n\nParameters\n\nσ       – observation error.\nseq     – the indexing sequence of the observed state, e.g. 2 for that state only, 3:4 for the third and fourth, etc.\ny_seq   – as above, the corresponding [indexing] values for the observations data, seq unless otherwise specified.\n\ntest latex eqn:\n\n\fracnk(n - k) = inomnk\n\nExamples\n\np = partial_gaussian_obs_model(1.0, seq = 2)\n\n\n\n\n\n","category":"function"},{"location":"manual/#Simulation","page":"Package manual","title":"Simulation","text":"","category":"section"},{"location":"manual/","page":"Package manual","title":"Package manual","text":"gillespie_sim","category":"page"},{"location":"manual/#DiscretePOMP.gillespie_sim","page":"Package manual","title":"DiscretePOMP.gillespie_sim","text":"gillespie_sim(model, parameters; tmax = 100.0, num_obs = 5)\n\nRun a Doob-Gillespie (DGA) simulation based on model.\n\nReturns a SimResults type containing the trajectory and observations data, or an array of the same if n_sims > 1.\n\nParameters\n\nmodel       – DPOMPModel (see [DCTMPs.jl models]@ref).\nparameters  – model parameters.\n\nOptional\n\ntmax        – maximum time (default: 100.)\nn_obs       – the number of observations to draw (default: 5.)\nn_sims      – number of simulations to draw (default: 1.)\n\nExample\n\nusing DiscretePOMP\nm = generate_model(\"SIR\", [50, 1, 0])\nx = DiscretePOMP.gillespie_sim(model, [0.005, 0.12])\nprintln(DiscretePOMP.plot_trajectory(x))\n\n\n\n\n\n","category":"function"},{"location":"manual/#Bayesian-inference","page":"Package manual","title":"Bayesian inference","text":"","category":"section"},{"location":"manual/","page":"Package manual","title":"Package manual","text":"run_mcmc_analysis\nrun_ibis_analysis\nrun_arq_mcmc_analysis","category":"page"},{"location":"manual/#DiscretePOMP.run_mcmc_analysis","page":"Package manual","title":"DiscretePOMP.run_mcmc_analysis","text":"run_mcmc_analysis(model, obs_data; ... )\n\nRun an n_chains-MCMC analysis using the designated algorithm (MBP-MCMC by default.)\n\nThe initial_parameters are sampled from the prior distribution unless otherwise specified by the user. A Gelman-Rubin convergence diagnostic is automatically carried out (for n_chains > 1) and included in the [multi-chain] analysis results.\n\nParameters\n\nmodel               – DPOMPModel (see [DCTMPs.jl models]@ref).\nobs_data            – Observations data.\n\nOptional\n\nn_chains            – number of Markov chains (default: 3.)\ninitial_parameters  – 2d array of initial model parameters. Each column vector correspondes to a single model parameter.\nsteps               – number of iterations.\nadapt_period        – number of discarded samples.\nmbp                 – model based proposals (MBP). Set mbp = false for standard proposals.\nppp                 – the proportion of parameter (vs. trajectory) proposals in Gibbs sampler. Default: 30%. NB. not required for MBP.\nfin_adapt           – finite adaptive algorithm. The default is false, i.e. [fully] adaptive.\nmvp                 – increase for a higher proportion of 'move' proposals. NB. not applicable if MBP = true (default: 2.)\n\nExample\n\ny = x.observations                          # some simulated data\nmodel = generate_model(\"SIR\", [50, 1, 0])   # a model\nresults = run_mcmc_analysis(model, y; fin_adapt = true) # finite-adaptive MCMC\ntabulate_results(results)                   # optionally, show the results\n\n\n\n\n\n","category":"function"},{"location":"manual/#DiscretePOMP.run_ibis_analysis","page":"Package manual","title":"DiscretePOMP.run_ibis_analysis","text":"run_ibis_analysis(model, obs_data; ... )\n\nRun an iterative-batch-importance-sampling (IBIS) analysis based on model and obs_data of type Observations.\n\nThe default algorithm is SMC^2 (i.e. particle filter IBIS), the other option is model-based-proposal IBIS (use algorithm = \"MBPI\".) Note that the default value of the optional parameters below is sometimes affected by choice of algorithm. However these are overridden when specified by the user.\n\nParameters\n\nmodel               – DPOMPModel (see [DCTMPs.jl models]@ref).\nobs_data            – Observations data.\n\nOptional parameters\n\nalgorithm           – String, per above.\nnp                  – number of [outer, i.e. theta] particles.\n\nAlgorithm options\n\ness_rs_crit         – resampling criteria.\nind_prop            – true for independent theta proposals.\nalpha               – increase to lower the targeted acceptance rate (default = 1.002.)\nnpf                 – number of [inner] particles for SMC^2 (default = 200.)\nn_props             – MBP mutations per step (default: 3.)\n\nExample\n\n# NB. using 'y' and 'model' as above\nresults = run_ibis_analysis(model, y)   # importance sample\ntabulate_results(results)               # show the results\n\n\n\n\n\n","category":"function"},{"location":"manual/#DiscretePOMP.run_arq_mcmc_analysis","page":"Package manual","title":"DiscretePOMP.run_arq_mcmc_analysis","text":"run_arq_mcmc_analysis(model, obs_data, theta_range; ... )\n\nRun ARQ-MCMC analysis with n_chains Markov chains.\n\nThe Gelman-Rubin convergence diagnostic is computed automatically.\n\nParameters\n\nmodel               – DPOMPModel (see docs.)\nobs_data            – Observations data.\nsample_interval     – An array specifying the (fixed or fuzzy) interval between samples.\n\nOptional\n\nsample_dispersal   – i.e. the length of each dimension in the importance sample.\nsample_limit        – sample limit, should be increased when the variance of model.pdf is high (default: 1.)\nn_chains            – number of Markov chains (default: 3.)\nsteps               – number of iterations.\nburnin              – number of discarded samples.\ntgt_ar              – acceptance rate (default: 0.33.)\nnp                  – number of SMC particles in PF (default: 200.)\ness_crit            – acceptance rate (default: 0.33.)\nsample_cache        – the underlying model likelihood cache - can be retained and reused for future analyses.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Bayesian-model-analysis","page":"Package manual","title":"Bayesian model analysis","text":"","category":"section"},{"location":"manual/","page":"Package manual","title":"Package manual","text":"run_model_comparison_analysis","category":"page"},{"location":"manual/#DiscretePOMP.run_model_comparison_analysis","page":"Package manual","title":"DiscretePOMP.run_model_comparison_analysis","text":"run_model_comparison_analysis(model, obs_data; ... )\n\nRun n_runs independent analyses for each DPOMPModel element in models, and compute [estimate] the Bayesian model evidence (BME.)\n\nReturns an object of type ModelComparisonResults, which includes the mean and standard deviation of the estimates obtained.\n\nParameters\n\nmodels          – An Array of DPOMPModel.\nobs_data        – An array of type Observation.\n\nOptional parameters\n\nn_runs          – number of independent analyses used to estimate the BME for each model.\nalgorithm       – String representing the inference method used for the analysis, \"SMC2\" for SMC^2 (default); or \"MBPI\" for MBP-IBIS.\n\nOptional inference algorithm parameters\n\nnp              – number of [outer, i.e. theta] particles used in IBIS procedures (doesn't apply to ARQ-MCMC.)\ness_rs_crit     – Effective sample size (ESS) resampling criteria.\nnpf             – number of particles used in particle filter (doesn't apply to MBP-IBIS.)\nn_props         – see the docs for run_mbp_ibis_analysis.\n\nExample\n\n# NB. first define some models to compare, e.g. as m1, m2, etc\nmodels = [m1, m2, m3]\nresults = run_model_comparison_analysis(models, y; n_runs = 10)\ntabulate_results(results)   # show the results (optional)\n\n\n\n\n\n","category":"function"},{"location":"manual/#Utilities","page":"Package manual","title":"Utilities","text":"","category":"section"},{"location":"manual/","page":"Package manual","title":"Package manual","text":"get_observations\ntabulate_results\nprint_results\nget_particle_filter_lpdf","category":"page"},{"location":"manual/#DiscretePOMP.get_observations","page":"Package manual","title":"DiscretePOMP.get_observations","text":"get_observations(source)\n\nReturn an array of type Observation, based on a two-dimensional array, DataFrame or file location (i.e. String.)\n\nNote that a observation times must be in the first column of the input variable.\n\n\n\n\n\n","category":"function"},{"location":"manual/#DiscretePOMP.tabulate_results","page":"Package manual","title":"DiscretePOMP.tabulate_results","text":"tabulate_results\n\nDisplay the results of an inference analysis.\n\nThe main parameter is results – a data structure of type MCMCSample, ImportanceSample, ARQMCMCSample or ModelComparisonResults. When invoking the latter, the named parameter null_index = 1 by default but can be overridden. This determines the 'null' model, used to compute the Bayes factor.\n\n\n\n\n\n","category":"function"},{"location":"manual/#DiscretePOMP.print_results","page":"Package manual","title":"DiscretePOMP.print_results","text":"print_results\n\nPrint the results of a parameter inference analysis to file.\n\nParameters\n\nsamples     – a data structure of type SimResults, ImportanceSample, MCMCSample or ARQMCMCSample.\ndpath       – the directory where the results will be saved.\n\n\n\n\n\n","category":"function"},{"location":"manual/#DiscretePOMP.get_particle_filter_lpdf","page":"Package manual","title":"DiscretePOMP.get_particle_filter_lpdf","text":"get_particle_filter_lpdf(model, obs_data; ... )\n\nGenerate a SMC [log] likelihood estimating function for a DPOMPModel – a.k.a. a particle filter.\n\nParameters\n\nmodel               – DPOMPModel (see [DCTMPs.jl models]@ref).\nobs_data            – Observations data.\n\nNamed parameters\n\nnp                  – number of particles.\nrs_type             – resampling method: 2 for stratified, 3 for multinomial, or 1 for systematic (the default.)\ness_rs_crit         – effective-sample-size resampling criteria.\n\n```\n\n\n\n\n\n","category":"function"},{"location":"manual/#Visualisation","page":"Package manual","title":"Visualisation","text":"","category":"section"},{"location":"manual/","page":"Package manual","title":"Package manual","text":"plot_trajectory\nplot_parameter_trace\nplot_parameter_marginal\nplot_parameter_heatmap\nplot_model_comparison","category":"page"},{"location":"manual/#DiscretePOMP.plot_trajectory","page":"Package manual","title":"DiscretePOMP.plot_trajectory","text":"plot_trajectory(x)\n\nPlot the trajectory of a a DGA simulation using UnicodePlots.jl.\n\nThe only input parameter required is x of type SimResults, i.e. from a call to gillespie_sim.\n\n\n\n\n\n","category":"function"},{"location":"manual/#DiscretePOMP.plot_parameter_trace","page":"Package manual","title":"DiscretePOMP.plot_parameter_trace","text":"plot_parameter_trace(mcmc, [parameter::Int64])\n\nProduce a trace plot of samples using UnicodePlots.jl.\n\nThe mcmc input is of type MCMCSample, ARQMCMCSample or RejectionSample. The parameter index can be optionally specified, else all parameters are plotted and returned as an Array of unicode plots.\n\n\n\n\n\n","category":"function"},{"location":"manual/#DiscretePOMP.plot_parameter_marginal","page":"Package manual","title":"DiscretePOMP.plot_parameter_marginal","text":"plot_parameter_marginal(sample, parameter)\n\nPlot the marginal distribution of samples from an MCMC analysis for a given model parameter using UnicodePlots.jl.\n\nParameters\n\nresults     – Results object, e.g. of type MCMCSample.\nparameter   – the index of the model parameter to be plotted.\nadapt_period– Adaptation period to be discarded, only required for RejectionSample.\n\nOptional\n\nuse_is      – Resample IS rather than using MCMC [re]samples (ARQMCMCSample results only.)\n\n\n\n\n\n","category":"function"},{"location":"manual/#DiscretePOMP.plot_parameter_heatmap","page":"Package manual","title":"DiscretePOMP.plot_parameter_heatmap","text":"plot_parameter_heatmap(mcmc, x_parameter, y_parameter)\n\nPlot the marginal distribution of samples from an MCMC analysis for two model parameters using UnicodePlots.jl.\n\nParameters\n\nmcmc        – MCMCResults, e.g. from a call to run_met_hastings_mcmc.\nx_parameter   – the index of the model parameter to be plotted on the x axis.\ny_parameter   – the index of the model parameter to be plotted on the y axis.\n\n\n\n\n\n","category":"function"},{"location":"manual/#DiscretePOMP.plot_model_comparison","page":"Package manual","title":"DiscretePOMP.plot_model_comparison","text":"plot_model_comparison(results; boxplot = true)\n\nPlot the Bayesian model evidence (BME) from a model comparison analysis, using UnicodePlots.jl.\n\nParameters\n\nresults   – ModelComparisonResults, i.e. from a call to run_model_comparison_analysis.\nboxplot   – true for a series of boxplots, else a simple UnicodePlots.barplot showing only the average BME for each model variant (default.)\n\n\n\n\n\n","category":"function"},{"location":"manual/#Advanced-features.","page":"Package manual","title":"Advanced features.","text":"","category":"section"},{"location":"manual/","page":"Package manual","title":"Package manual","text":"This section covers functionality for customising the algorithms themselves.","category":"page"},{"location":"manual/","page":"Package manual","title":"Package manual","text":"run_custom_mcmc_analysis\ngenerate_custom_particle","category":"page"},{"location":"manual/#DiscretePOMP.run_custom_mcmc_analysis","page":"Package manual","title":"DiscretePOMP.run_custom_mcmc_analysis","text":"run_custom_mcmc_analysis(model, obs_data, trajectory_prop, [x0_prop], ... )\n\nRun an n_chains data-augmented MCMC analysis, based on the Gibbs sampler with a user defined proposal function.\n\nA function for conditionally sampling the initial trajectory variable can optionally be specified, use the Doob-Gillespie algorithm is used by default.\n\nElsewise, this function is equivalent to calling runmcmcanalysis with mbp = false, which invokes the standard Gibbs sampler.\n\nParameters\n\nmodel               – DPOMPModel (see [DCTMPs.jl models]@ref).\nobs_data            – Observations data.\ntrajectory_prop     – .\nx0_prop             – Initial state variable sampler, DGA by default.\n\nOptional\n\nn_chains            – number of Markov chains (optional, default: 3.)\ninitial_parameters  – 2d array of initial model parameters. Each column vector correspondes to a single model parameter.\nsteps               – number of iterations.\nadapt_period        – number of discarded samples.\nppp                 – the proportion of parameter (vs. trajectory) proposals in Gibbs sampler. Default: 0.3, or 30%.\nfin_adapt           – finite adaptive algorithm. The default is false, i.e. [fully] adaptive.\n\n\n\n\n\n","category":"function"},{"location":"manual/#DiscretePOMP.generate_custom_particle","page":"Package manual","title":"DiscretePOMP.generate_custom_particle","text":"generate_custom_particle(model, obs_data, trajectory_prop, [x0_prop], ... )\n\nFor use with run_custom_mcmc_analysis(). Initialises a Particle based on an array of type Event. Also evaluates the likelihood function.\n\nParameters\n\nmodel               – DPOMPModel (see [DCTMPs.jl models]@ref).\nobs_data            – Observations data.\ntrajectory          – Array of Event types.\n\nOptional\n\ntheta               – model parameters, sampled from prior unless otherwise specified.\n\n\n\n\n\n","category":"function"},{"location":"manual/#Index","page":"Package manual","title":"Index","text":"","category":"section"},{"location":"manual/","page":"Package manual","title":"Package manual","text":"","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"DiscretePOMP.jl is a package for:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Bayesian parameter inference, and\nSimulation of,\nDiscrete-state-space Partially Observed Markov Processes, in Julia.\nIt also includes automated tools for things like convergence diagnosis, model assessment and analysis.","category":"page"},{"location":"#What-are-DPOMP-models?","page":"Introduction","title":"What are DPOMP models?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Discrete-state-space (DSS) models are used throughout ecology and other scientific domains to represent systems comprised of interacting components (e.g. people or molecules.)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A well-known example is the Kermack-McKendrick susceptible-infectious-susceptible (SIR) model:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"<img src=\"https://raw.githubusercontent.com/mjb3/DiscretePOMP.jl/master/docs/img/sir.png\" alt=\"SIR model\" style=\"height: 80px;\"/>","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"See the Simple example for a brief primer on DSS.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In applied situations (e.g. like a scientific study) such systems are often difficult to directly observe, and so they are referred to in context as being Partially Observed.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The dynamics (how the system changes over time) of the SIR, and other DSS models, can be represented in continuous time by [a set of coupled] Markov Processes. More specifically, we can define a probability density (a 'likelihood function' in Bayesian parlance) that governs the time-evolution of the system under study.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Combining these concepts, we have a general class of statistical model: Discrete-state-space Partially Observed Markov Processes, or Discrete POMP.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Furthermore, given some applicable [partially complete] scientific data, they yield a paradigm for (in this case, Bayesian) statistical inference based on that model class. That is, we can infer [the likely value of] unknown quantities, such as the unknown time of a known event (like the introduction of a pathogen,) or a model parameter that characterises the infectiousness of that pathogen.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"To summarise, DPOMP models and associated methods allow us to learn about a given system of interest (e.g. an ecosystem, pandemic, chemical reaction, and so on,) even in when the available data is limited ['partial'].","category":"page"},{"location":"#Scientific-applications","page":"Introduction","title":"Scientific applications","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Discrete POMP, and discrete-state-space models in general, have a wide range of applications including:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Epidemiological modelling (e.g. SEIR models)\nEcology (e.g. predator-prey dynamics)\nMany other potential use cases, e.g. physics; chemical reactions; social media.","category":"page"},{"location":"#Package-features","page":"Introduction","title":"Package features","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The algorithms implemented by the package for simulation and inference include:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The Gillespie direct method algorithm\nData-augmented Markov chain Monte Carlo (MCMC)\nThe model-based-proposal (MBP) algorithm[1].\nSequential Monte Carlo (i.e. particle filters)\nSMC^2[2], or iterative-batch-importance sampling (IBIS)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"[1]: C. M. Pooley, S. C. Bishop, and G. Marion. Using model-based proposals for fast parameter inference on discrete state space, continuous-time Markov processes. Journal of The Royal Society Interface, 12(107):20150225–20150225, May 2015.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"[2]: N. Chopin, P. E. Jacob, and O. Papaspiliopoulos. SMC^2 : an efficient algorithm for sequential analysis of state space models: Sequential Analysis of State Space Models. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 75(3):397–426, June 2013.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A number of well-known models are provided as predefined examples:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"SIR, SEIR, and other epidemiological model\nThe Lotka-Voltera predator-prey model\nRoss-MacDonald two-species malaria model","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The package code was initially developed during the course of a postgraduate research project in infectious disease modelling at Biostatistics Scotland, and there is a heavy emphasis on epidemiology and epidemiological modelling throughout.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In practice though, this affects only the applied examples and naming conventions of the predefined models available with the package. Otherwise, the models and methods are applicable to many situations entirely outwith the field of ecology (such as chemical reactions.)","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"As a prerequisite, the package naturally requires a working installation of the Julia programming language. The package is not yet registered but can nonetheless must be added via the package manager Pkg in the usual way.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"From the Julia REPL type ] to enter the Pkg mode, and run:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> add https://github.com/mjb3/DiscretePOMP.jl","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"See the package code repository to inspect the source code.","category":"page"},{"location":"#Documentation","page":"Introduction","title":"Documentation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"models.md\",\n    \"examples.md\",\n    \"manual.md\",\n]\nDepth = 2","category":"page"}]
}
